--- ../src-base/minecraft/net/minecraft/world/World.java
+++ ../src-work/minecraft/net/minecraft/world/World.java
@@ -3,21 +3,25 @@
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
+import java.util.Set;
 import java.util.UUID;
-import java.util.function.Supplier;
-
 import javax.annotation.Nullable;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockLiquid;
-import net.minecraft.block.BlockObserver;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
@@ -25,12 +29,23 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityArmorStand;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.item.EntityXPOrb;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Biomes;
 import net.minecraft.init.Blocks;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.Packet;
+import net.minecraft.network.play.server.SPacketWorldBorder;
 import net.minecraft.pathfinding.PathWorldListener;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.Scoreboard;
@@ -46,24 +61,43 @@
 import net.minecraft.util.SoundEvent;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.village.VillageCollection;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.biome.BiomeProvider;
+import net.minecraft.world.border.IBorderListener;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
 import net.minecraft.world.storage.ISaveHandler;
+import net.minecraft.world.storage.MapData;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
 import net.minecraft.world.storage.WorldSavedData;
 import net.minecraft.world.storage.loot.LootTableManager;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.ForgeChunkManager.Ticket;
+import net.minecraftforge.common.util.BlockSnapshot;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.v1_12_R1.CraftServer;
+import org.bukkit.craftbukkit.v1_12_R1.CraftWorld;
+import org.bukkit.craftbukkit.v1_12_R1.event.CraftEventFactory;
+import org.bukkit.craftbukkit.v1_12_R1.util.CraftMagicNumbers;
+import org.bukkit.entity.NPC;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.generator.ChunkGenerator;
+import org.magmafoundation.magma.configuration.MagmaConfig;
 
+
 public abstract class World implements IBlockAccess, net.minecraftforge.common.capabilities.ICapabilityProvider
 {
     /**
@@ -76,11 +110,11 @@
     private int seaLevel = 63;
     protected boolean scheduledUpdatesAreImmediate;
     public final List<Entity> loadedEntityList = Lists.<Entity>newArrayList();
-    protected final List<Entity> unloadedEntityList = Lists.<Entity>newArrayList();
-    public final List<TileEntity> loadedTileEntityList = Lists.<TileEntity>newArrayList();
+    protected final Set<Entity> unloadedEntityList = Sets.newHashSet(); // Paper
+    // public List<TileEntity> loadedTileEntityList = Lists.<TileEntity>newArrayList(); // Paper - remove unused list
     public final List<TileEntity> tickableTileEntities = Lists.<TileEntity>newArrayList();
     private final List<TileEntity> addedTileEntityList = Lists.<TileEntity>newArrayList();
-    private final List<TileEntity> tileEntitiesToBeRemoved = Lists.<TileEntity>newArrayList();
+    private final Set<TileEntity> tileEntitiesToBeRemoved = Sets.newHashSet(); // Paper
     public final List<EntityPlayer> playerEntities = Lists.<EntityPlayer>newArrayList();
     public final List<Entity> weatherEffects = Lists.<Entity>newArrayList();
     protected final IntHashMap<Entity> entitiesById = new IntHashMap<Entity>();
@@ -94,36 +128,168 @@
     public float thunderingStrength;
     private int lastLightningBolt;
     public final Random rand = new Random();
-    public final WorldProvider provider;
+    public WorldProvider provider;
     protected PathWorldListener pathListener = new PathWorldListener();
     protected List<IWorldEventListener> eventListeners;
-    protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider;
     protected final ISaveHandler saveHandler;
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo;
+    public WorldInfo worldData; // Magma - Bukkit NMS worldData copy of worldInfo
     protected boolean findingSpawnPoint;
-    protected MapStorage mapStorage;
+    public MapStorage mapStorage;
     public VillageCollection villageCollection;
     protected LootTableManager lootTable;
     protected AdvancementManager advancementManager;
     protected FunctionManager functionManager;
     public final Profiler profiler;
     private final Calendar calendar;
-    protected Scoreboard worldScoreboard;
+    public Scoreboard worldScoreboard;
     public final boolean isRemote;
-    protected boolean spawnHostileMobs;
-    protected boolean spawnPeacefulMobs;
+    public boolean spawnHostileMobs;
+    public boolean spawnPeacefulMobs;
     private boolean processingLoadedTiles;
     private final WorldBorder worldBorder;
     int[] lightUpdateBlockList;
 
     public boolean restoringBlockSnapshots = false;
     public boolean captureBlockSnapshots = false;
-    public java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot>();
+    public ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new ArrayList<net.minecraftforge.common.util.BlockSnapshot>();
     private net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
     private net.minecraftforge.common.util.WorldCapabilityData capabilityData;
 
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+    public boolean captureTreeGeneration = false;
+    public List<EntityItem> captureDrops;
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    private int tickPosition;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+
+    public final co.aikar.timings.WorldTimingsHandler timings; // Paper
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    private ImmutableSetMultimap<ChunkPos, Ticket> forcedChunks = ImmutableSetMultimap.of();
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    // Paper start
+    public Chunk getChunkIfLoaded(BlockPos blockposition) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+    // Paper end
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(info.getWorldName()); // Spigot
+        this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(info.getWorldName(), this.spigotConfig); // Paper
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
+        this.eventListeners = Lists.newArrayList(this.pathListener);
+        this.calendar = Calendar.getInstance();
+        this.worldScoreboard = new Scoreboard();
+        this.spawnHostileMobs = true;
+        this.spawnPeacefulMobs = true;
+        this.lightUpdateBlockList = new int[32768];
+        this.saveHandler = saveHandlerIn;
+        this.profiler = profilerIn;
+        this.worldInfo = info;
+        this.provider = providerIn;
+        this.isRemote = client;
+        this.worldBorder = providerIn.createWorldBorder();
+        perWorldStorage = new MapStorage((ISaveHandler) null);
+        // Magma start
+        if (this.worldInfo
+            != null) // Use saved dimension from level.dat. Fixes issues with MultiVerse
+        {
+            if (this.worldInfo.getDimension() != 0) {
+                this.provider.setDimension(this.worldInfo.getDimension());
+            } else {
+                this.worldInfo.setDimension(this.provider.getDimension());
+            }
+        }
+
+        if (this.worldInfo.getDimension() == 0) {
+            generator = this.getServer().getGenerator(this.worldInfo.getWorldName());
+            getWorld().generator = generator;
+        }
+        // Magma end
+        // CraftBukkit start
+        getWorldBorder().world = (WorldServer) this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().addListener(new IBorderListener() {
+            public void onSizeChanged(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(
+                    new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_SIZE),
+                    worldborder.world);
+            }
+
+            public void onTransitionStarted(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(
+                    new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.LERP_SIZE),
+                    worldborder.world);
+            }
+
+            public void onCenterChanged(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(
+                    new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_CENTER),
+                    worldborder.world);
+            }
+
+            public void onWarningTimeChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(
+                    new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_WARNING_TIME),
+                    worldborder.world);
+            }
+
+            public void onWarningDistanceChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder,
+                    SPacketWorldBorder.Action.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void onDamageAmountChanged(WorldBorder worldborder, double d0) {
+            }
+
+            public void onDamageBufferChanged(WorldBorder worldborder, double d0) {
+            }
+        });
+        this.getServer().addWorld(this.world);
+        // CraftBukkit end
+        timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
+        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+
+        // Magma - worldData
+        worldData = worldInfo;
+    }
+
     protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
     {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( info.getWorldName() ); // Spigot
+        this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(info.getWorldName(), this.spigotConfig); // Paper
+        this.world = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).getWorld() : null;
         this.eventListeners = Lists.newArrayList(this.pathListener);
         this.calendar = Calendar.getInstance();
         this.worldScoreboard = new Scoreboard();
@@ -137,6 +303,12 @@
         this.isRemote = client;
         this.worldBorder = providerIn.createWorldBorder();
         perWorldStorage = new MapStorage((ISaveHandler)null);
+        timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
+        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+        // Magma - worldData
+        worldData = worldInfo;
     }
 
     public World init()
@@ -215,14 +387,14 @@
         return this.getBlockState(blockpos);
     }
 
-    public boolean isValid(BlockPos pos)
+    public boolean isValid(BlockPos pos) // Paper - unused but incase reflection / future uses
     {
-        return !this.isOutsideBuildHeight(pos) && pos.getX() >= -30000000 && pos.getZ() >= -30000000 && pos.getX() < 30000000 && pos.getZ() < 30000000;
+        return pos.isValidLocation(); // Paper
     }
 
     public boolean isOutsideBuildHeight(BlockPos pos)
     {
-        return pos.getY() < 0 || pos.getY() >= 256;
+        return pos.isInvalidYLocation(); // Paper
     }
 
     public boolean isAirBlock(BlockPos pos)
@@ -232,7 +404,7 @@
 
     public boolean isBlockLoaded(BlockPos pos)
     {
-        return this.isBlockLoaded(pos, true);
+        return getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4) != null; // Paper
     }
 
     public boolean isBlockLoaded(BlockPos pos, boolean allowEmpty)
@@ -298,7 +470,7 @@
         }
     }
 
-    protected abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
+    public abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
 
     public Chunk getChunkFromBlockCoords(BlockPos pos)
     {
@@ -317,7 +489,27 @@
 
     public boolean setBlockState(BlockPos pos, IBlockState newState, int flags)
     {
-        if (this.isOutsideBuildHeight(pos))
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration && Bukkit.isPrimaryThread()) {
+            net.minecraftforge.common.util.BlockSnapshot blocksnapshot = null;
+
+            for (net.minecraftforge.common.util.BlockSnapshot previous : this.capturedBlockSnapshots)
+            {
+                if (previous.getPos().equals(pos))
+                {
+                    blocksnapshot = previous;
+                    break;
+                }
+            }
+            if (blocksnapshot != null)
+            {
+                this.capturedBlockSnapshots.remove(blocksnapshot);
+            }
+            this.capturedBlockSnapshots.add(new net.minecraftforge.common.util.BlockSnapshot(this, pos, newState, flags));
+            return true;
+        }
+        // CraftBukkit end
+        if (pos.isInvalidYLocation())
         {
             return false;
         }
@@ -341,7 +533,9 @@
             int oldOpacity = oldState.getLightOpacity(this, pos);
 
             IBlockState iblockstate = chunk.setBlockState(pos, newState);
+            if (MagmaConfig.instance.expMergeMaxValue.getValues() == 1) {
 
+            }
             if (iblockstate == null)
             {
                 if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
@@ -352,7 +546,8 @@
                 if (newState.getLightOpacity(this, pos) != oldOpacity || newState.getLightValue(this, pos) != oldLight)
                 {
                     this.profiler.startSection("checkLight");
-                    this.checkLight(pos);
+                    BlockPos finalPos = pos;
+                    chunk.runOrQueueLightUpdate(() -> checkLight(finalPos)); // Paper - Queue light update
                     this.profiler.endSection();
                 }
 
@@ -437,6 +632,11 @@
     {
         if (this.worldInfo.getTerrainType() != WorldType.DEBUG_ALL_BLOCK_STATES)
         {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
             this.notifyNeighborsOfStateChange(pos, blockType, p_175722_3_);
         }
     }
@@ -486,6 +686,7 @@
 
     public void notifyNeighborsOfStateChange(BlockPos pos, Block blockType, boolean updateObservers)
     {
+        if (captureBlockSnapshots) { return; } // Paper - Cancel all physics during placement
         if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(EnumFacing.class), updateObservers).isCanceled())
             return;
 
@@ -548,6 +749,17 @@
 
             try
             {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer) this).getWorld();
+                if (world != null && !((WorldServer)this).stopPhysicsEvent) { // Paper
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn), fromPos.getX(), fromPos.getY(), fromPos.getZ()); // Paper - add source block
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
                 iblockstate.neighborChanged(this, pos, blockIn, fromPos);
             }
             catch (Throwable throwable)
@@ -586,6 +798,11 @@
                 {
                     iblockstate.getBlock().observedNeighborChange(iblockstate, this, pos, p_190529_2_, p_190529_3_);
                 }
+                catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                    haveWeSilencedAPhysicsCrash = true;
+                    blockLocation = pos.getX() + ", " + pos.getY() + ", " + pos.getZ();
+                    // Spigot End
+                }
                 catch (Throwable throwable)
                 {
                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
@@ -669,6 +886,41 @@
         }
     }
 
+    // Paper start - test if meets light level, return faster
+    // logic copied from below
+    public boolean isLightLevel(BlockPos blockposition, int level) {
+        if (blockposition.isValidLocation()) {
+            if (this.getBlockState(blockposition).useNeighborBrightness()) {
+                if (this.getLight(blockposition.up(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.east(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.west(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.south(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.north(), false) >= level) {
+                    return true;
+                }
+                return false;
+            } else {
+                if (blockposition.getY() >= 256) {
+                    blockposition = new BlockPos(blockposition.getX(), 255, blockposition.getZ());
+                }
+
+                Chunk chunk = this.getChunkFromBlockCoords(blockposition);
+                return chunk.getLightSubtracted(blockposition, this.getSkylightSubtracted()) >= level;
+            }
+        } else {
+            return true;
+        }
+    }
+    // Paper end
+
     public int getLightFromNeighbors(BlockPos pos)
     {
         return this.getLight(pos, true);
@@ -718,6 +970,7 @@
                 {
                     pos = new BlockPos(pos.getX(), 255, pos.getZ());
                 }
+                if (!this.isBlockLoaded(pos)) return 0; // Paper
 
                 Chunk chunk = this.getChunkFromBlockCoords(pos);
                 return chunk.getLightSubtracted(pos, this.skylightSubtracted);
@@ -792,7 +1045,7 @@
                 pos = new BlockPos(pos.getX(), 0, pos.getZ());
             }
 
-            if (!this.isValid(pos))
+            if (!pos.isValidLocation()) // Paper
             {
                 return type.defaultLightValue;
             }
@@ -845,7 +1098,7 @@
             pos = new BlockPos(pos.getX(), 0, pos.getZ());
         }
 
-        if (!this.isValid(pos))
+        if (!pos.isValidLocation()) // Paper
         {
             return type.defaultLightValue;
         }
@@ -862,7 +1115,7 @@
 
     public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue)
     {
-        if (this.isValid(pos))
+        if (pos.isValidLocation()) // Paper
         {
             if (this.isBlockLoaded(pos))
             {
@@ -900,18 +1153,62 @@
         return this.provider.getLightBrightnessTable()[this.getLightFromNeighbors(pos)];
     }
 
-    public IBlockState getBlockState(BlockPos pos)
+    // Paper start - reduces need to do isLoaded before getType
+    public IBlockState getTypeIfLoaded(BlockPos blockposition) {
+        // CraftBukkit start - tree generation
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
+        if (captureTreeGeneration) {
+            final IBlockState previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
+            }
+        }
+        // CraftBukkit end
+        Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
+        if (chunk != null) {
+            return chunk.getBlockState(x, y, z);
+        }
+        return null;
+    }
+    // Paper end
+
+    public IBlockState getBlockState(BlockPos blockposition)
     {
-        if (this.isOutsideBuildHeight(pos))
-        {
-            return Blocks.AIR.getDefaultState();
+		// CraftBukkit start - tree generation
+        // Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
+        if (captureTreeGeneration)
+		{
+            final IBlockState previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
+            }
         }
-        else
-        {
-            Chunk chunk = this.getChunkFromBlockCoords(pos);
-            return chunk.getBlockState(pos);
+        // CraftBukkit end
+
+        return this.chunkProvider.provideChunk(x >> 4, z >> 4).getBlockStatePaper(x, y, z);
+        // Paper end
+    }
+
+    // Paper start
+    private IBlockState getCapturedBlockType(int x, int y, int z) {
+        Iterator<BlockSnapshot> it = capturedBlockSnapshots.iterator();
+        while (it.hasNext()) {
+            BlockSnapshot previous = it.next();
+            BlockPos position = previous.getPos();
+            if (position.getX() == x && position.getY() == y && position.getZ() == z) {
+                int typeId = net.minecraft.block.Block.getIdFromBlock(previous.getReplacedBlock().getBlock());
+                int data = previous.getMeta();
+                return CraftMagicNumbers.getBlock(typeId).getStateFromMeta(data);
+            }
         }
+        return null;
     }
+    // Paper end
 
     public boolean isDaytime()
     {
@@ -944,7 +1241,8 @@
                 int i1 = MathHelper.floor(vec31.y);
                 int j1 = MathHelper.floor(vec31.z);
                 BlockPos blockpos = new BlockPos(l, i1, j1);
-                IBlockState iblockstate = this.getBlockState(blockpos);
+                IBlockState iblockstate = this.getTypeIfLoaded(blockpos); // paper
+                if (iblockstate == null) return null; // Paper
                 Block block = iblockstate.getBlock();
 
                 if ((!ignoreBlockWithoutBoundingBox || iblockstate.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB) && block.canCollideCheck(iblockstate, stopOnLiquid))
@@ -1077,7 +1375,8 @@
                     i1 = MathHelper.floor(vec31.y) - (enumfacing == EnumFacing.UP ? 1 : 0);
                     j1 = MathHelper.floor(vec31.z) - (enumfacing == EnumFacing.SOUTH ? 1 : 0);
                     blockpos = new BlockPos(l, i1, j1);
-                    IBlockState iblockstate1 = this.getBlockState(blockpos);
+                    IBlockState iblockstate1 = this.getTypeIfLoaded(blockpos); // Paper
+                    if (iblockstate1 == null) return null; // Paper
                     Block block1 = iblockstate1.getBlock();
 
                     if (!ignoreBlockWithoutBoundingBox || iblockstate1.getMaterial() == Material.PORTAL || iblockstate1.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB)
@@ -1181,14 +1480,93 @@
 
     public boolean spawnEntity(Entity entityIn)
     {
+        // CraftBukkit start - Used for entities other than creatures
+        return spawnEntity(entityIn, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    // Magma - Bukkit Name
+    public boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        return spawnEntity(entity, spawnReason);
+    }
+
+    public boolean spawnEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        if (entity == null) return false;
+        if (entity.valid) { MinecraftServer.LOGGER.error("Attempted Double World add on " + entity, new Throwable()); return true; } // Paper
+
+        org.bukkit.event.Cancellable event = null;
+        if (entity instanceof EntityLivingBase && !(entity instanceof EntityPlayerMP)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterMob || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMob || entity instanceof EntityGhast || entity instanceof EntitySlime;
+            boolean isNpc = entity instanceof NPC;
+
+            if (spawnReason != CreatureSpawnEvent.SpawnReason.CUSTOM) {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs || isNpc && !getServer().getServer().getCanSpawnNPCs()) {
+                    entity.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLivingBase) entity, spawnReason);
+        } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Vehicle){
+            event = CraftEventFactory.callVehicleCreateEvent(entity);
+        }
+
+        // Spigot start
+        else if (entity instanceof EntityXPOrb) {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                // Paper start - Maximum exp value when merging - Whole section has been tweaked, see comments for specifics
+                final int maxValue = paperConfig.expMergeMaxValue;
+                final boolean mergeUnconditionally = paperConfig.expMergeMaxValue <= 0;
+                if (mergeUnconditionally || xp.xpValue < maxValue) { // Paper - Skip iteration if unnecessary
+                    List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.getEntityBoundingBox().grow(radius, radius, radius));
+                    for (Entity e : entities) {
+                        if (e instanceof EntityXPOrb) {
+                            EntityXPOrb loopItem = (EntityXPOrb) e;
+                            // Paper start
+                            if (!loopItem.isDead && !(maxValue > 0 && loopItem.xpValue >= maxValue)) {
+                                long newTotal = (long)xp.xpValue + (long)loopItem.xpValue;
+                                if ((int) newTotal < 0) continue; // Overflow
+                                if (maxValue > 0 && newTotal > (long)maxValue) {
+                                    loopItem.xpValue = (int) (newTotal - maxValue);
+                                    xp.xpValue = maxValue;
+                                } else {
+                                    xp.xpValue += loopItem.xpValue;
+                                    loopItem.setDead();
+                                }
+                                // Paper end
+                            }
+                        }
+                    }
+                } // Paper end - End iteration skip check - All tweaking ends here
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.isDead)) {
+            entity.isDead = true;
+            return false;
+        }
+        // CraftBukkit end
         // do not drop any items while restoring blocksnapshots. Prevents dupes
-        if (!this.isRemote && (entityIn == null || (entityIn instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
+        if (!this.isRemote && (entity == null || (entity instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
 
-        int i = MathHelper.floor(entityIn.posX / 16.0D);
-        int j = MathHelper.floor(entityIn.posZ / 16.0D);
-        boolean flag = entityIn.forceSpawn;
+        int i = MathHelper.floor(entity.posX / 16.0D);
+        int j = MathHelper.floor(entity.posZ / 16.0D);
+        boolean flag = true; // Paper - always load chunks
 
-        if (entityIn instanceof EntityPlayer)
+        // Paper start - Set origin location when the entity is being added to the world
+        if (entity.origin == null) {
+            entity.origin = entity.getBukkitEntity().getLocation();
+        }
+        // Paper end
+
+        if (entity instanceof EntityPlayer)
         {
             flag = true;
         }
@@ -1199,18 +1577,19 @@
         }
         else
         {
-            if (entityIn instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer entityplayer = (EntityPlayer)entityIn;
+                EntityPlayer entityplayer = (EntityPlayer)entity;
                 this.playerEntities.add(entityplayer);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)) && !flag) return false;
+            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity, this)) && !flag) return false;
 
-            this.getChunkFromChunkCoords(i, j).addEntity(entityIn);
-            this.loadedEntityList.add(entityIn);
-            this.onEntityAdded(entityIn);
+            this.getChunkFromChunkCoords(i, j).addEntity(entity);
+            if (entity.isDead) return false; // Paper - don't add dead entities, chunk registration may of killed it
+            this.loadedEntityList.add(entity);
+            this.onEntityAdded(entity);
             return true;
         }
     }
@@ -1222,6 +1601,9 @@
             ((IWorldEventListener)this.eventListeners.get(i)).onEntityAdded(entityIn);
         }
         entityIn.onAddedToWorld();
+        entityIn.valid = true; // CraftBukkit
+        entityIn.shouldBeRemoved = false; // Paper - shouldn't be removed after being re-added
+        new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
     }
 
     public void onEntityRemoved(Entity entityIn)
@@ -1231,6 +1613,8 @@
             ((IWorldEventListener)this.eventListeners.get(i)).onEntityRemoved(entityIn);
         }
         entityIn.onRemovedFromWorld();
+        new com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
+        entityIn.valid = false; // CraftBukkit
     }
 
     public void removeEntity(Entity entityIn)
@@ -1250,6 +1634,20 @@
         if (entityIn instanceof EntityPlayer)
         {
             this.playerEntities.remove(entityIn);
+            // Spigot start
+            for (Object o : mapStorage.loadedDataList) {
+                if (o instanceof MapData) {
+                    MapData map = (MapData) o;
+                    map.playersHashMap.remove(entityIn);
+                    for (Iterator<MapData.MapInfo> iter = map.playersArrayList.iterator(); iter.hasNext(); ) {
+                        if (iter.next().player == entityIn) {
+                            map.mapDecorations.remove(entityIn.getUniqueID()); // Paper
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+            // Spigot end
             this.updateAllPlayersSleepingFlag();
             this.onEntityRemoved(entityIn);
         }
@@ -1273,8 +1671,18 @@
         {
             this.getChunkFromChunkCoords(i, j).removeEntity(entityIn);
         }
+        entityIn.shouldBeRemoved = true; // Paper
 
-        this.loadedEntityList.remove(entityIn);
+        // this.loadedEntityList.remove(entityIn);
+        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        int index = this.loadedEntityList.indexOf(entityIn);
+        if (index != -1) {
+            if (index <= this.tickPosition) {
+                this.tickPosition--;
+            }
+            this.loadedEntityList.remove(index);
+        }
+        // CraftBukkit end
         this.onEntityRemoved(entityIn);
     }
 
@@ -1366,6 +1774,7 @@
 
         if (entityIn != null)
         {
+            if (entityIn instanceof EntityArmorStand && !entityIn.world.paperConfig.armorStandEntityLookups) return list; // Paper
             List<Entity> list1 = this.getEntitiesWithinAABBExcludingEntity(entityIn, aabb.grow(0.25D));
 
             for (int i = 0; i < list1.size(); ++i)
@@ -1677,7 +2086,11 @@
         for (int i = 0; i < this.weatherEffects.size(); ++i)
         {
             Entity entity = this.weatherEffects.get(i);
-
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null || entity.isDead || entity.valid) { // Paper - prevent adding already added or dead entities
+                continue;
+            }
+            // CraftBukkit end
             try
             {
                 if(entity.updateBlocked) continue;
@@ -1704,7 +2117,7 @@
                     removeEntity(entity);
                 }
                 else
-                throw new ReportedException(crashreport);
+                    throw new ReportedException(crashreport);
             }
 
             if (entity.isDead)
@@ -1714,36 +2127,52 @@
         }
 
         this.profiler.endStartSection("remove");
+        timings.entityRemoval.startTiming(); // Paper
         this.loadedEntityList.removeAll(this.unloadedEntityList);
 
-        for (int k = 0; k < this.unloadedEntityList.size(); ++k)
-        {
-            Entity entity1 = this.unloadedEntityList.get(k);
-            int j = entity1.chunkCoordX;
-            int k1 = entity1.chunkCoordZ;
+        int j;
 
-            if (entity1.addedToChunk && this.isChunkLoaded(j, k1, true))
+        // Paper start - Set based removal lists
+        for (Entity e : this.unloadedEntityList) {
+             /*
+            j = e.getChunkZ();
+            int k = e.getChunkX();
+
+            if (e.addedToChunk && this.isChunkLoaded(k, j, true))
             {
-                this.getChunkFromChunkCoords(j, k1).removeEntity(entity1);
-            }
+                this.getChunkFromChunkCoords(k, j).removeEntity(e);
+            }*/
+            Chunk chunk = e.isAddedToChunk() ? e.getCurrentChunk() : null;
+            if (chunk != null) chunk.removeEntity(e);
         }
 
-        for (int l = 0; l < this.unloadedEntityList.size(); ++l)
-        {
-            this.onEntityRemoved(this.unloadedEntityList.get(l));
+        for (Entity e : this.unloadedEntityList) {
+            this.onEntityRemoved(e);
         }
+        // Paper end
 
         this.unloadedEntityList.clear();
         this.tickPlayers();
+        timings.entityRemoval.stopTiming(); // Paper
         this.profiler.endStartSection("regular");
 
-        for (int i1 = 0; i1 < this.loadedEntityList.size(); ++i1)
-        {
-            Entity entity2 = this.loadedEntityList.get(i1);
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        // CraftBukkit start - Use field for loop variable
+        co.aikar.timings.TimingHistory.entityTicks += this.loadedEntityList.size(); // Paper
+        // Paper start - Disable tick limiters
+        //if (tickPosition < 0) tickPosition = 0;
+        for (tickPosition = 0; tickPosition < loadedEntityList.size(); tickPosition++) {
+            // Paper end
+            if (playerEntities.size() < 1) {
+                continue;
+            }
+            tickPosition = (tickPosition < loadedEntityList.size()) ? tickPosition : 0;
+            Entity entity2 = (Entity) this.loadedEntityList.get(this.tickPosition);
+            // CraftBukkit end
             Entity entity3 = entity2.getRidingEntity();
 
-            if (entity3 != null)
-            {
+            if (entity3 != null) {
                 if (!entity3.isDead && entity3.isPassenger(entity2))
                 {
                     continue;
@@ -1758,12 +2187,15 @@
             {
                 try
                 {
+                    entity2.tickTimer.startTiming(); // Paper
                     net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(entity2);
                     this.updateEntity(entity2);
                     net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(entity2);
+                    entity2.tickTimer.stopTiming(); // Paper
                 }
                 catch (Throwable throwable1)
                 {
+                    entity2.tickTimer.stopTiming();
                     CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Entity being ticked");
                     entity2.addEntityCrashInfo(crashreportcategory1);
@@ -1773,7 +2205,7 @@
                         removeEntity(entity2);
                     }
                     else
-                    throw new ReportedException(crashreport1);
+                        throw new ReportedException(crashreport1);
                 }
             }
 
@@ -1782,22 +2214,31 @@
 
             if (entity2.isDead)
             {
+                // Paper start
+                /*
                 int l1 = entity2.chunkCoordX;
                 int i2 = entity2.chunkCoordZ;
 
                 if (entity2.addedToChunk && this.isChunkLoaded(l1, i2, true))
                 {
                     this.getChunkFromChunkCoords(l1, i2).removeEntity(entity2);
-                }
+                }*/
+                Chunk chunk = entity2.isAddedToChunk() ? entity2.getCurrentChunk() : null;
+                if (chunk != null) chunk.removeEntity(entity2);
+                // Paper end
 
-                this.loadedEntityList.remove(i1--);
+                if (this.tickPosition < this.loadedEntityList.size()){
+                    this.loadedEntityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                }
                 this.onEntityRemoved(entity2);
             }
 
             this.profiler.endSection();
         }
 
+        timings.entityTick.stopTiming(); // Spigot
         this.profiler.endStartSection("blockEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
 
         this.processingLoadedTiles = true; //FML Move above remove to prevent CMEs
 
@@ -1805,14 +2246,16 @@
         {
             for (Object tile : tileEntitiesToBeRemoved)
             {
-               ((TileEntity)tile).onChunkUnload();
+                ((TileEntity)tile).onChunkUnload();
             }
 
             // forge: faster "contains" makes this removal much more efficient
+            // Paper start - Use alternate implementation with faster contains
             java.util.Set<TileEntity> remove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
             remove.addAll(tileEntitiesToBeRemoved);
             this.tickableTileEntities.removeAll(remove);
-            this.loadedTileEntityList.removeAll(remove);
+            // Paper end
+            // this.loadedTileEntityList.removeAll(remove); // Paper - remove unused list
             this.tileEntitiesToBeRemoved.clear();
         }
 
@@ -1826,40 +2269,48 @@
             {
                 BlockPos blockpos = tileentity.getPos();
 
-                if (this.isBlockLoaded(blockpos, false) && this.worldBorder.contains(blockpos)) //Forge: Fix TE's getting an extra tick on the client side....
-                {
+                // Paper start - Skip ticking in chunks scheduled for unload
+                Chunk chunk = tileentity.getCurrentChunk();
+                boolean shouldTick = chunk != null;
+                if(this.paperConfig.skipEntityTickingInChunksScheduledForUnload)
+                    shouldTick = shouldTick && !chunk.isUnloading() && chunk.scheduledForUnload == null;
+                if (shouldTick && this.worldBorder.contains(blockpos)) {
+                    // Paper end
                     try
                     {
                         this.profiler.func_194340_a(() ->
                         {
                             return String.valueOf((Object)TileEntity.getKey(tileentity.getClass()));
                         });
+                        tileentity.tickTimer.startTiming(); // Spigot
                         net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackStart(tileentity);
                         ((ITickable)tileentity).update();
                         net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackEnd(tileentity);
                         this.profiler.endSection();
                     }
-                    catch (Throwable throwable)
-                    {
+                    catch (Throwable throwable) {
                         CrashReport crashreport2 = CrashReport.makeCrashReport(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory2 = crashreport2.makeCategory("Block entity being ticked");
                         tileentity.addInfoToCrashReport(crashreportcategory2);
-                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities)
-                        {
+                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities) {
                             net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport2.getCompleteReport());
                             tileentity.invalidate();
                             this.removeTileEntity(tileentity.getPos());
-                        }
-                        else
-                        throw new ReportedException(crashreport2);
+                        } else
+                            throw new ReportedException(crashreport2);
                     }
+                    // Spigot start
+                    finally {
+                        tileentity.tickTimer.stopTiming();
+                    }
+                    // Spigot end
                 }
             }
 
             if (tileentity.isInvalid())
             {
                 iterator.remove();
-                this.loadedTileEntityList.remove(tileentity);
+                // this.loadedTileEntityList.remove(tileentity); // Paper - remove unused list
 
                 if (this.isBlockLoaded(tileentity.getPos()))
                 {
@@ -1871,6 +2322,8 @@
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.processingLoadedTiles = false;
         this.profiler.endStartSection("pendingBlockEntities");
 
@@ -1882,10 +2335,12 @@
 
                 if (!tileentity1.isInvalid())
                 {
+                    /* CraftBukkit start - Order matters, moved down
                     if (!this.loadedTileEntityList.contains(tileentity1))
                     {
                         this.addTileEntity(tileentity1);
                     }
+                    // CraftBukkit end */
 
                     if (this.isBlockLoaded(tileentity1.getPos()))
                     {
@@ -1893,6 +2348,12 @@
                         IBlockState iblockstate = chunk.getBlockState(tileentity1.getPos());
                         chunk.addTileEntity(tileentity1.getPos(), tileentity1);
                         this.notifyBlockUpdate(tileentity1.getPos(), iblockstate, iblockstate, 3);
+                        // CraftBukkit start
+                        // From above, don't screw this up - SPIGOT-1746
+                        if (true) { // Paper - remove unused list
+                            this.addTileEntity(tileentity1);
+                        }
+                        // CraftBukkit end
                     }
                 }
             }
@@ -1900,6 +2361,8 @@
             this.addedTileEntityList.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
+        co.aikar.timings.TimingHistory.tileEntityTicks += this.tickableTileEntities.size(); // Paper
         this.profiler.endSection();
         this.profiler.endSection();
     }
@@ -1915,7 +2378,7 @@
         // Forge: wait to add new TE if we're currently processing existing ones
         if (processingLoadedTiles) return addedTileEntityList.add(tile);
 
-        boolean flag = this.loadedTileEntityList.add(tile);
+        boolean flag = true; // Paper - remove unused list
 
         if (flag && tile instanceof ITickable)
         {
@@ -1976,6 +2439,14 @@
             }
         }
 
+        // Spigot start
+        if (forceUpdate && !org.spigotmc.ActivationRange.checkIfActive(entityIn)) {
+            entityIn.ticksExisted++;
+            entityIn.inactiveTick();
+            return;
+        }
+       // Spigot end
+
         entityIn.lastTickPosX = entityIn.posX;
         entityIn.lastTickPosY = entityIn.posY;
         entityIn.lastTickPosZ = entityIn.posZ;
@@ -1994,6 +2465,7 @@
             {
                 if(!entityIn.updateBlocked)
                 entityIn.onUpdate();
+                entityIn.postTick();
             }
         }
 
@@ -2025,7 +2497,7 @@
         }
 
         int i3 = MathHelper.floor(entityIn.posX / 16.0D);
-        int j3 = MathHelper.floor(entityIn.posY / 16.0D);
+        int j3 = Math.min(15, Math.max(0, MathHelper.floor(entityIn.posY / 16.0D))); // Paper - stay consistent with chunk add/remove behavior
         int k3 = MathHelper.floor(entityIn.posZ / 16.0D);
 
         if (!entityIn.addedToChunk || entityIn.chunkCoordX != i3 || entityIn.chunkCoordY != j3 || entityIn.chunkCoordZ != k3)
@@ -2035,7 +2507,7 @@
                 this.getChunkFromChunkCoords(entityIn.chunkCoordX, entityIn.chunkCoordZ).removeEntityAtIndex(entityIn, entityIn.chunkCoordY);
             }
 
-            if (!entityIn.setPositionNonDirty() && !this.isChunkLoaded(i3, k3, true))
+            if (!entityIn.valid && !entityIn.setPositionNonDirty() && !this.isChunkLoaded(i3, k3, true))  // Paper - always load to new chunk if valid
             {
                 entityIn.addedToChunk = false;
             }
@@ -2068,6 +2540,29 @@
         return this.checkNoEntityCollision(bb, (Entity)null);
     }
 
+    // Paper start - Based on method below
+    /**
+     * @param axisalignedbb area to search within
+     * @param entity causing the action ex. block placer
+     * @return if there are no visible players colliding
+     */
+    public boolean checkNoVisiblePlayerCollisions(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
+        List list = this.getEntitiesWithinAABBExcludingEntity((Entity) null, axisalignedbb);
+        for (int i = 0; i < list.size(); ++i) {
+            Entity entity1 = (Entity) list.get(i);
+            if (entity instanceof EntityPlayerMP && entity1 instanceof EntityPlayerMP) {
+                if (!((EntityPlayerMP) entity).getBukkitEntity().canSee(((EntityPlayerMP) entity1).getBukkitEntity())) {
+                    continue;
+                }
+            }
+            if (!entity1.isDead && entity1.blocksEntitySpawning()) {
+                return false;
+            }
+        }
+        return true;
+    }
+    // Paper end
+
     public boolean checkNoEntityCollision(AxisAlignedBB bb, @Nullable Entity entityIn)
     {
         List<Entity> list = this.getEntitiesWithinAABBExcludingEntity((Entity)null, bb);
@@ -2381,15 +2876,21 @@
         return this.chunkProvider.makeString();
     }
 
+    public Map<BlockPos, TileEntity> capturedTileEntities = Maps.newHashMap();
     @Nullable
     public TileEntity getTileEntity(BlockPos pos)
     {
-        if (this.isOutsideBuildHeight(pos))
+        if (pos.isInvalidYLocation()) // Paper
         {
             return null;
         }
         else
         {
+            // CraftBukkit start
+            if (capturedTileEntities.containsKey(pos)) {
+                return capturedTileEntities.get(pos);
+            }
+            // CraftBukkit end
             TileEntity tileentity2 = null;
 
             if (this.processingLoadedTiles)
@@ -2418,7 +2919,7 @@
         {
             TileEntity tileentity2 = this.addedTileEntityList.get(j2);
 
-            if (!tileentity2.isInvalid() && tileentity2.getPos().equals(pos))
+            if (tileentity2 != null && !tileentity2.isInvalid() && tileentity2.getPos().equals(pos))
             {
                 return tileentity2;
             }
@@ -2430,7 +2931,7 @@
     public void setTileEntity(BlockPos pos, @Nullable TileEntity tileEntityIn)
     {
         pos = pos.toImmutable(); // Forge - prevent mutable BlockPos leaks
-        if (!this.isOutsideBuildHeight(pos))
+        if (!pos.isInvalidYLocation()) // Paper
         {
             if (tileEntityIn != null && !tileEntityIn.isInvalid())
             {
@@ -2454,6 +2955,7 @@
                     }
 
                     toInvalidate.forEach(TileEntity::invalidate);
+                    tileEntityIn.setWorld(this); // Spigot - No null worlds
                     this.addedTileEntityList.add(tileEntityIn);
                 }
                 else
@@ -2474,15 +2976,15 @@
         {
             tileentity2.invalidate();
             this.addedTileEntityList.remove(tileentity2);
-            if (!(tileentity2 instanceof ITickable)) //Forge: If they are not tickable they wont be removed in the update loop.
-                this.loadedTileEntityList.remove(tileentity2);
+//            if (!(tileentity2 instanceof ITickable)) //Forge: If they are not tickable they wont be removed in the update loop.
+                // this.loadedTileEntityList.remove(tileentity2); // Paper - remove unused list
         }
         else
         {
             if (tileentity2 != null)
             {
                 this.addedTileEntityList.remove(tileentity2);
-                this.loadedTileEntityList.remove(tileentity2);
+                // this.loadedTileEntityList.remove(tileentity2); // Paper - remove unused list
                 this.tickableTileEntities.remove(tileentity2);
             }
 
@@ -2504,7 +3006,7 @@
 
     public boolean isBlockNormalCube(BlockPos pos, boolean _default)
     {
-        if (this.isOutsideBuildHeight(pos))
+        if (pos.isInvalidYLocation()) // Paper
         {
             return false;
         }
@@ -2662,6 +3164,13 @@
                 }
 
                 this.rainingStrength = MathHelper.clamp(this.rainingStrength, 0.0F, 1.0F);
+                // CraftBukkit start
+                for (int idx = 0; idx < this.playerEntities.size(); ++idx) {
+                    if (((EntityPlayerMP) this.playerEntities.get(idx)).world == this) {
+                        ((EntityPlayerMP) this.playerEntities.get(idx)).tickWeather();
+                    }
+                }
+                // CraftBukkit end
             }
         }
     }
@@ -2849,10 +3358,11 @@
         }
     }
 
-    public boolean checkLightFor(EnumSkyBlock lightType, BlockPos pos)
-    {
-        if (!this.isAreaLoaded(pos, 16, false))
-        {
+    public boolean checkLightFor(EnumSkyBlock lightType, BlockPos pos) {
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        Chunk chunk = this.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk == null || !this.isAreaLoaded(pos, 16, false)) {
+            // CraftBukkit end
             return false;
         }
         else
@@ -3039,6 +3549,7 @@
 
         for (Entity entity4 : this.loadedEntityList)
         {
+            if (entity4.shouldBeRemoved) continue; // Paper
             if (entityType.isAssignableFrom(entity4.getClass()) && filter.apply((T)entity4))
             {
                 list.add((T)entity4);
@@ -3054,6 +3565,7 @@
 
         for (Entity entity4 : this.playerEntities)
         {
+            if (entity4.shouldBeRemoved) continue; // Paper
             if (playerType.isAssignableFrom(entity4.getClass()) && filter.apply((T)entity4))
             {
                 list.add((T)entity4);
@@ -3142,7 +3654,16 @@
 
         for (Entity entity4 : this.loadedEntityList)
         {
-            if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity4 instanceof EntityLiving) {
+                EntityLiving entityinsentient = (EntityLiving) entity4;
+                if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                    continue;
+                }
+            }
+
+            // if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
+            if (entityType.isAssignableFrom(entity4.getClass()))
             {
                 ++j2;
             }
@@ -3157,6 +3678,9 @@
         {
             if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity4, this)))
             {
+                if (entity4 == null || entity4.isDead || entity4.valid) { // Paper - prevent adding already added or dead entities
+                    continue;
+                }
                 loadedEntityList.add(entity4);
                 this.onEntityAdded(entity4);
             }
@@ -3173,19 +3697,26 @@
         IBlockState iblockstate1 = this.getBlockState(pos);
         AxisAlignedBB axisalignedbb = skipCollisionCheck ? null : blockIn.getDefaultState().getCollisionBoundingBox(this, pos);
 
+        boolean defaultReturn;
         if (!((placer instanceof EntityPlayer) || !net.minecraftforge.event.ForgeEventFactory.onBlockPlace(placer, new net.minecraftforge.common.util.BlockSnapshot(this, pos, blockIn.getDefaultState()), sidePlacedOn).isCanceled())) return false;
-        if (axisalignedbb != Block.NULL_AABB && !this.checkNoEntityCollision(axisalignedbb.offset(pos))) // Forge: Remove second parameter, we patch placer to be non-null, passing it here skips collision checks for the placer
+        if (axisalignedbb != Block.NULL_AABB && !this.checkNoVisiblePlayerCollisions(axisalignedbb.offset(pos), placer)) // Forge: Remove second parameter, we patch placer to be non-null, passing it here skips collision checks for the placer
         {
-            return false;
+            defaultReturn = false;
         }
         else if (iblockstate1.getMaterial() == Material.CIRCUITS && blockIn == Blocks.ANVIL)
         {
-            return true;
+            defaultReturn = true;
         }
         else
         {
-            return iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
+            defaultReturn= iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
         }
+
+        // CraftBukkit start - store default return
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+        return event.isBuildable();
+        // CraftBukkit end
     }
 
     public int getSeaLevel()
@@ -3350,6 +3881,12 @@
         {
             EntityPlayer entityplayer1 = this.playerEntities.get(j2);
 
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead) {
+                continue;
+            }
+            // CraftBukkit end
+
             if (p_190525_9_.apply(entityplayer1))
             {
                 double d1 = entityplayer1.getDistanceSq(x, y, z);
@@ -3371,7 +3908,7 @@
         {
             EntityPlayer entityplayer = this.playerEntities.get(j2);
 
-            if (EntitySelectors.NOT_SPECTATING.apply(entityplayer))
+            if (EntitySelectors.NOT_SPECTATING.apply(entityplayer) && entityplayer.affectsSpawning) // Paper - Affects Spawning API
             {
                 double d0 = entityplayer.getDistanceSq(x, y, z);
 
@@ -3595,8 +4132,19 @@
 
     public void updateAllPlayersSleepingFlag()
     {
+        ((WorldServer) this).updateAllPlayersSleepingFlag();
     }
 
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus() {
+        if (!this.isRemote) {
+            this.updateAllPlayersSleepingFlag();
+        }
+    }
+    // CraftBukkit end
+
     public float getThunderStrength(float delta)
     {
         return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * delta) * this.getRainStrength(delta);
@@ -3882,10 +4430,11 @@
     public boolean isSpawnChunk(int x, int z)
     {
         BlockPos blockpos1 = this.getSpawnPoint();
-        int j2 = x * 16 + 8 - blockpos1.getX();
-        int k2 = z * 16 + 8 - blockpos1.getZ();
-        int l2 = 128;
-        return j2 >= -128 && j2 <= 128 && k2 >= -128 && k2 <= 128;
+        int k = x * 16 + 8 - blockpos1.getX();
+        int l = z * 16 + 8 - blockpos1.getZ();
+        short keepLoadedRange = paperConfig.keepLoadedRange; // Paper
+
+        return k >= -keepLoadedRange && k <= keepLoadedRange && l >= -keepLoadedRange && l <= keepLoadedRange && this.keepSpawnInMemory; // CraftBukkit - Added 'this.keepSpawnInMemory' // Paper - Re-add range var
     }
 
     /* ======================================== FORGE START =====================================*/
