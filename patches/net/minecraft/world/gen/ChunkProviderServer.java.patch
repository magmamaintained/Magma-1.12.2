--- ../src-base/minecraft/net/minecraft/world/gen/ChunkProviderServer.java
+++ ../src-work/minecraft/net/minecraft/world/gen/ChunkProviderServer.java
@@ -1,5 +1,7 @@
 package net.minecraft.world.gen;
 
+import co.aikar.timings.Timing;
+import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -23,19 +25,45 @@
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.chunk.storage.AnvilChunkLoader;
 import net.minecraft.world.chunk.storage.IChunkLoader;
+import net.minecraftforge.common.DimensionManager;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.event.world.ChunkUnloadEvent;
 
 public class ChunkProviderServer implements IChunkProvider
 {
     private static final Logger LOGGER = LogManager.getLogger();
-    private final Set<Long> droppedChunksSet = Sets.<Long>newHashSet();
+    public final Set<Long> droppedChunksSet = Sets.<Long>newHashSet();
     public final IChunkGenerator chunkGenerator;
     public final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> id2ChunkMap = new Long2ObjectOpenHashMap<Chunk>(8192);
+    // Paper start - chunk save stats
+    private long lastQueuedSaves = 0L; // Paper
+    private long lastProcessedSaves = 0L; // Paper
+    private long lastSaveStatPrinted = System.currentTimeMillis();
+    // Paper end
+    // Paper start
+    protected Chunk lastChunkByPos = null;
+    public Long2ObjectOpenHashMap<Chunk> id2ChunkMap = new Long2ObjectOpenHashMap<Chunk>(8192) {
+        @Override
+        public Chunk get(long key) {
+            if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
+                return lastChunkByPos;
+            }
+            return lastChunkByPos = super.get(key);
+        }
+        @Override
+        public Chunk remove(long key) {
+            if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
+                lastChunkByPos = null;
+            }
+            return super.remove(key);
+        }
+    }; // CraftBukkit
+    // Paper end
     public final WorldServer world;
-    private final Set<Long> loadingChunks = com.google.common.collect.Sets.newHashSet();
+    private final Set<Long> loadingChunks = Sets.newHashSet();
 
     public ChunkProviderServer(WorldServer worldObjIn, IChunkLoader chunkLoaderIn, IChunkGenerator chunkGeneratorIn)
     {
@@ -69,6 +97,12 @@
         }
     }
 
+    // Paper start
+    public boolean isChunkGenerated(int x, int z) {
+        return this.id2ChunkMap.containsKey(ChunkPos.asLong(x, z)) || this.chunkLoader.isChunkGeneratedAt(x, z);
+    }
+    // Paper end
+
     @Nullable
     public Chunk getLoadedChunk(int x, int z)
     {
@@ -83,6 +117,10 @@
         return chunk;
     }
 
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return id2ChunkMap.get(ChunkPos.asLong(x, z));
+    }
+
     @Nullable
     public Chunk loadChunk(int x, int z)
     {
@@ -92,7 +130,12 @@
     @Nullable
     public Chunk loadChunk(int x, int z, @Nullable Runnable runnable)
     {
-        Chunk chunk = this.getLoadedChunk(x, z);
+        return getChunkAt(x, z, runnable, true);
+    }
+
+    public Chunk getChunkAt(int x, int z, Runnable runnable, boolean generate)
+    {
+        Chunk chunk = world.paperConfig.allowPermaChunkLoaders ? getLoadedChunk(x, z) : getChunkIfLoaded(x, z); // Paper - Configurable perma chunk loaders
         if (chunk == null)
         {
             long pos = ChunkPos.asLong(x, z);
@@ -106,7 +149,7 @@
                 {
                 this.id2ChunkMap.put(ChunkPos.asLong(x, z), chunk);
                 chunk.onLoad();
-                chunk.populate(this, this.chunkGenerator);
+                chunk.populateCB(this, this.chunkGenerator, false);
                 }
 
                 loadingChunks.remove(pos);
@@ -116,6 +159,13 @@
                 net.minecraft.world.chunk.storage.AnvilChunkLoader loader = (net.minecraft.world.chunk.storage.AnvilChunkLoader) this.chunkLoader;
                 if (runnable == null || !net.minecraftforge.common.ForgeChunkManager.asyncChunkLoading)
                     chunk = net.minecraftforge.common.chunkio.ChunkIOExecutor.syncChunkLoad(this.world, loader, this, x, z);
+
+                // Paper start - If there was an issue loading the chunk from region, stage1 will fail and stage2 will load it sync
+                // all we need to do is fetch an instance
+                if (chunk == null) {
+                    chunk = getChunkIfLoaded(x, z);
+                }
+                // Paper end
                 else if (loader.isChunkGeneratedAt(x, z))
                 {
                     // We can only use the async queue for already generated chunks
@@ -123,6 +173,8 @@
                     return null;
                 }
             }
+        } else if (chunk == null && generate) {
+            chunk = provideChunk(x, z);
         }
 
         // If we didn't load the chunk async and have a callback run it now
@@ -154,7 +206,7 @@
 
             this.id2ChunkMap.put(i, chunk);
             chunk.onLoad();
-            chunk.populate(this, this.chunkGenerator);
+            chunk.populateCB(this, this.chunkGenerator, true);
         }
 
         return chunk;
@@ -177,7 +229,11 @@
         }
         catch (Exception exception)
         {
-            LOGGER.error("Couldn't load chunk", (Throwable)exception);
+            // Paper start
+            String msg = "Couldn\'t load chunk";
+            ChunkProviderServer.LOGGER.error(msg, exception);
+            ServerInternalException.reportInternalException(exception);
+            // Paper end
             return null;
         }
     }
@@ -186,34 +242,74 @@
     {
         try
         {
-            this.chunkLoader.saveExtraChunkData(this.world, chunkIn);
+            // this.chunkLoader.saveExtraChunkData(this.world, chunkIn); // Spigot
         }
         catch (Exception exception)
         {
-            LOGGER.error("Couldn't save entities", (Throwable)exception);
+            // Paper start
+            String msg = "Couldn\'t save entities";
+            ChunkProviderServer.LOGGER.error(msg, exception);
+            ServerInternalException.reportInternalException(exception);
+            // Paper end
         }
     }
 
-    private void saveChunkData(Chunk chunkIn)
-    {
-        try
+    private void saveChunkData(Chunk chunkIn,  boolean unloaded) { // Spigot
+        try (Timing timed = world.timings.chunkSaveData.startTiming())
         {
             chunkIn.setLastSaveTime(this.world.getTotalWorldTime());
-            this.chunkLoader.saveChunk(this.world, chunkIn);
+            this.chunkLoader.saveChunk(this.world, chunkIn, unloaded); // Spigot
         }
         catch (IOException ioexception)
         {
-            LOGGER.error("Couldn't save chunk", (Throwable)ioexception);
+            // Paper start
+            String msg = "Couldn\'t save chunk";
+            ChunkProviderServer.LOGGER.error(msg, ioexception);
+            ServerInternalException.reportInternalException(ioexception);
         }
         catch (MinecraftException minecraftexception)
         {
-            LOGGER.error("Couldn't save chunk; already in use by another instance of Minecraft?", (Throwable)minecraftexception);
+            String msg = "Couldn\'t save chunk; already in use by another instance of Minecraft?";
+            ChunkProviderServer.LOGGER.error(msg, minecraftexception);
+            ServerInternalException.reportInternalException(minecraftexception);
         }
     }
 
     public boolean saveChunks(boolean all)
     {
         int i = 0;
+
+        // Paper start
+        final AnvilChunkLoader chunkLoader = (AnvilChunkLoader) world.getChunkProvider().chunkLoader;
+        final int queueSize = chunkLoader.getQueueSize();
+
+        final long now = System.currentTimeMillis();
+        final long timeSince = (now - lastSaveStatPrinted) / 1000;
+        final Integer printRateSecs = Integer.getInteger("printSaveStats");
+        if (printRateSecs != null && timeSince >= printRateSecs) {
+            final String timeStr = "/" + timeSince  +"s";
+            final long queuedSaves = chunkLoader.getQueuedSaves();
+            long queuedDiff = queuedSaves - lastQueuedSaves;
+            lastQueuedSaves = queuedSaves;
+            final long processedSaves = chunkLoader.getProcessedSaves();
+            long processedDiff = processedSaves - lastProcessedSaves;
+            lastProcessedSaves = processedSaves;
+            lastSaveStatPrinted = now;
+            if (processedDiff > 0 || queueSize > 0 || queuedDiff > 0) {
+                System.out.println("[Chunk Save Stats] " + world.worldData.getWorldName() +
+                    " - Current: " + queueSize +
+                    " - Queued: " + queuedDiff + timeStr +
+                    " - Processed: " +processedDiff + timeStr
+                );
+            }
+        }
+
+        if (queueSize > world.paperConfig.queueSizeAutoSaveThreshold){
+            return false;
+        }
+        final int autoSaveLimit = world.paperConfig.maxAutoSaveChunksPerTick;
+        // Paper end
+
         List<Chunk> list = Lists.newArrayList(this.id2ChunkMap.values());
 
         for (int j = 0; j < list.size(); ++j)
@@ -227,12 +323,11 @@
 
             if (chunk.needsSaving(all))
             {
-                this.saveChunkData(chunk);
+                this.saveChunkData(chunk, false); // Spigot
                 chunk.setModified(false);
                 ++i;
 
-                if (i == 24 && !all)
-                {
+                if (!all && i >= autoSaveLimit) { // Spigot - // Paper - Incremental Auto Save - cap max per tick
                     return false;
                 }
             }
@@ -246,12 +341,19 @@
         this.chunkLoader.flush();
     }
 
+    private static final double UNLOAD_QUEUE_RESIZE_FACTOR = 0.96;
     public boolean tick()
     {
         if (!this.world.disableLevelSaving)
         {
             if (!this.droppedChunksSet.isEmpty())
             {
+                // Spigot start
+                org.spigotmc.SlackActivityAccountant activityAccountant = this.world.getMinecraftServer().slackActivityAccountant;
+                activityAccountant.startActivity(0.5);
+                int targetSize = Math.min(this.droppedChunksSet.size() - 100,  (int) (this.droppedChunksSet.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
+                // Spigot end
+
                 for (ChunkPos forced : this.world.getPersistentChunks().keySet())
                 {
                     this.droppedChunksSet.remove(ChunkPos.asLong(forced.x, forced.z));
@@ -259,31 +361,87 @@
 
                 Iterator<Long> iterator = this.droppedChunksSet.iterator();
 
-                for (int i = 0; i < 100 && iterator.hasNext(); iterator.remove())
-                {
+                while (iterator.hasNext()) { // Spigot
                     Long olong = iterator.next();
+                    iterator.remove(); // Spigot
                     Chunk chunk = (Chunk)this.id2ChunkMap.get(olong);
 
                     if (chunk != null && chunk.unloadQueued)
                     {
-                        chunk.onUnload();
-                        net.minecraftforge.common.ForgeChunkManager.putDormantChunk(ChunkPos.asLong(chunk.x, chunk.z), chunk);
-                        this.saveChunkData(chunk);
-                        this.saveChunkExtraData(chunk);
-                        this.id2ChunkMap.remove(olong);
-                        ++i;
+                        // CraftBukkit start - move unload logic to own method
+                        chunk.setShouldUnload(false); // Paper
+                        if (!unloadChunk(chunk, true)) {
+                            continue;
+                        }
+                        // CraftBukkit end
+
+                        // Spigot start
+                        if (this.id2ChunkMap.size() <= targetSize && activityAccountant.activityTimeIsExhausted()) {
+                            break;
+                        }
+                        // Spigot end
                     }
                 }
+                activityAccountant.endActivity(); // Spigot
             }
 
-            if (this.id2ChunkMap.isEmpty()) net.minecraftforge.common.DimensionManager.unloadWorld(this.world.provider.getDimension());
+            int dim = this.world.provider.getDimension();
+            if (this.id2ChunkMap.isEmpty() && !DimensionManager.isBukkitDimension(dim)) DimensionManager.unloadWorld(dim);
 
+            // Paper start - delayed chunk unloads
+            long now = System.currentTimeMillis();
+            long unloadAfter = world.paperConfig.delayChunkUnloadsBy;
+            if (unloadAfter > 0) {
+                //noinspection Convert2streamapi
+                for (Chunk chunk : id2ChunkMap.values()) {
+                    if (chunk.scheduledForUnload != null && now - chunk.scheduledForUnload > unloadAfter) {
+                        chunk.scheduledForUnload = null;
+                        queueUnload(chunk);
+                    }
+                }
+            }
+            // Paper end
+
             this.chunkLoader.chunkTick();
         }
 
         return false;
     }
 
+    // CraftBukkit start
+    public boolean unloadChunk(Chunk chunk, boolean save) {
+        ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk, save);
+        this.world.getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return false;
+        }
+        save = event.isSaveChunk();
+        chunk.lightingQueue.processUnload(); // Paper
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = this.getChunkIfLoaded(chunk.x + x, chunk.z + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborUnloaded(-x, -z);
+                    chunk.setNeighborUnloaded(x, z);
+                }
+            }
+        }
+        // Moved from unloadChunks above
+        chunk.onUnload();
+        net.minecraftforge.common.ForgeChunkManager.putDormantChunk(ChunkPos.asLong(chunk.x, chunk.z), chunk);
+        this.saveChunkData(chunk, true);
+        this.saveChunkExtraData(chunk);
+        this.id2ChunkMap.remove(chunk.chunkKey);
+        return true;
+    }
+    // CraftBukkit end
+
     public boolean canSave()
     {
         return !this.world.disableLevelSaving;
@@ -324,4 +482,5 @@
     {
         return this.id2ChunkMap.containsKey(ChunkPos.asLong(x, z)) || this.chunkLoader.isChunkGeneratedAt(x, z);
     }
+
 }
